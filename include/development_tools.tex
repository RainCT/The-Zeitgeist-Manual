\section{Languages used}

\subsection{Zeitgeist Engine}
The Zeitgeist engine is primarily written in Python and minimum supported version is Python 2.7


\subsection{Zeitgeist Datahub}
Zeitgeist datahub is a passive logger for zeitgeist. It is written in 
vala, since it gives a great flexilitties. It gives us the good features 
of a high level language which compiles down to native code. 

The high level language features helps in bringing down the effort we
put in maintaince, so that the workforce can be used in work which needs 
more attention. It helps us in an efficient use of manpower, esp in a 
voulenteer run project.

On the performace side, it needs to be lightweight as it is running all 
the time. The earlier python based datahub used 5 times more memory.

\subsection{Libraries and Datasources}
We have a libraries which are basically language or framework bindings 
for Zeitgeist API. Most of these bindings actually wrap over the 
Zeitgeist DBus API using the dbus binding for that specific package. 
We have bindings for Python, C/Vala, Qt and Mono.

Datasources are written in multiple languages and uses the language which 
the application supports. Example Emacs datasource is written in lisp, 
tomboy datasource is written in C\#, Rhythmbox datasource is written in 
python and so on.
\subsection{Why Python for Engine?}
GNOME Zeitgeist started from the Gimmie/Mayanna codebase that was written 
in python. The tradition continued. Although we had several thoughts to move 
to Mono, C and Vala it never happened for several reasons. 
\begin{itemize}
\item Mono would have created a big debate in the community since a lot of 
GNOME hackers dislike it, however at the very beginning all ZG developers were 
keen with mono, yet to ensure no political issues we decided to stay with python.
\item C was and still is an issue since, only a few or the core devs are familiar 
with C and we will lose momentum.
\item Vala would have made Zeitgeist more a GNOME project than a desktop project 
and there is not much gain now in moving to any other programing language since 
speed and memory consumption wont be affected heavily in comparison to the effort 
we will have to put in it. That time Vala wasn't an option either because it 
doesn't support some D-Bus features we needed.
\end{itemize}


\section{Other technologies}
\subsection{SQLite}
\subsection{DBus}
\subsection{GLib}

\section{Launchpad}

Launchpad is a web based application for software development and collaboration for 
free software. It is actually a suite of various services which is tightly integrated 
with each other. Some of the services are:
\begin{itemize}
\item Code hosting (uses Bazaar)
\item Bug tracker (codenamed Malone)
\item Question and Answers
\item Package Management (codenamed Soyuz)
\item Translations (codenamed Rosetta)
\item Blueprints
\item Registry - Projects, Teams and Mailing lists
\end{itemize}

Launchpad is a great development and collaborative platform which is already being used 
to develop Ubuntu, the most famous and widespread Linux distribution. Apart from the 
distribution there are many other smaller or bigger projects which are developed like 
Drizzle, Inkscape, Upstart, Zope3, OpenStack, Bazaar, OpenShot, Docky and MySQL.

\subsection{Why Launchpad is good for our workflow}
\subsection{How we found value in Launchpad's bug tracker}
Launchpad's bug tracker contains many good features which are of immense help for our 
project. Some of them are
\begin{enumerate}
\item A problem in zeitgeist can affect various modules of zeitgeist. It is important for 
us to track the same bug in all the modules. Instead of having multiple bugs opened for 
all for them, one bug reports tracks status in all the affected modules.
\item Since Ubuntu also uses Launchpad for management, we can track an issue in our codebase 
as well as the one present in Ubuntu at the same time. It also allows us to track the issues 
of zeitgeist in each ubutu version seperately which helps us know the complete history 
of the current problem.
\item An problem in zeitgeist might be due to a bug in one of our dependencies which might 
not be developed in Launchpad. In such a case this same issue is opened upstream on that 
project's bug tracker and a \textit{bug watch} is added to the corrosponding issue in Launchpad. 
The work of bug tracker is to keep a watch on the upstream bug and import the updates from that 
upstream bug on Launchpad so that the bug triagers or developers don't have to keep watch 
everywhere. This simplifies bug management.
\item Launchpad allows us to subscribe to bug reports. The beauty of this subscription is that 
it allows us to configure our subscription to fine-grained level on each bug seperately. It 
allows someone to subscribe someone anyone on a bug.
\item It keeps the comments on the bug and the changes made to the status and importance of 
each affected project seperately. Patches and attachment are also shown in the comment in 
strict oldest to newer order. All the attachments and patches are also shown on the right 
side if someone is interested in looking at all of them, especially in bug reports with lots 
of activity.
\end{enumerate}
\subsection{Why tightly integrated Launchpad helps us}

\section{Bazaar}
Bazaar is a distributed version control system. Using a distributed version control 
system like bazaar developers can collaborate in a completely distributed manner 
without having to know what code changes the other developer is doing. Every developer 
has a complete copy of the source code with all the change history.

To collaborate amongst the developers there is a centralized server where all the 
developers can push code and pull changes made by others. Let us imagine a scenario 
in which various developers have to collaborate.
\begin{enumerate}
\item The central server contains the source code.
\item Three developers make a clone of the source code using bazaar.
\item All three of them go to some place without an internet connection.
\item All of them keep making changes to the codebase.
\item Developer A pushes his code on the server.
\item Rest two developers pull from the server and get Developer A's changes.
\item Developer B pushes his changes.
\item Developer A and C pull the changes.
\item Developer A has B's changes and Developer B has Developer A's changes.
\item Developer C has changes from all the two developers plus his own.
\item Developer C pushes the changes on the server.
\item Developer A and B pull th changes from the server.
\item Now all the three developers have each other changes and server has changes 
from all three of them.
\end{enumerate}

Bazaar also maintains history of the changes. It can be told to keep a watch on the 
files specified and it can then tell which files have changes and what has changed. It 
can even tell the contents which has changes. After making some changes we can commit the 
changes. Each commit is like a \textbf{milestone}. All the changes made after the commit are 
called changes, which can be then committed. Anytime a person can see the changes 
made between the various commits. 

It is advisable to have one logical unit of work in a commit instead of making 10,000 
lines of changes in a single commit. Example changes made to add a new entry in the toolbar 
can qualify as a commit. If the changes are very big, then this should be broken down into 
smaller and more managable changes. 

There are many reasons for keeping the changes in a single commit small and managable: 

\begin{itemize}
\item The changes made between commits can be viewed by a diff tool like \textit{kdiff} and \textit{meld}. 
If changes are small, reading and understanding the changes is easier.
\item When changes are small, it is easy to find out the commit which introduced a regression.
\item Many times code is submitted for review before it is accepted. Having a huge 8000 lines 
of changes makes it very difficult for the maintainer of the project to understand.
\end{itemize}

\subsection{Why did we pick up Bazaar}
There were multiple reasons why we chose Bazaar and then later continued with it: 
\begin{itemize}
\item The initial code of Zeitgeist was uploaded on Launchpad which uses Bazaar version control system.
\item Bazaar is simple to use. It takes less time to learn.
\item Bazaar has great integration with Launchpad. This is one important factor.
\item Bazaar has simpler branching and merging concept than other version control systems.
\item We want to make the entry barrier low to the new contributers. We want them to spend more time 
on implementing the actual thing than spend time learning a version control system.
\end{itemize}

\subsection{How tough is to migrate to something else}
There are two major reasons why we do not merge to some other version control system: 
\begin{itemize}
\item It takes time to learn a new distributed version control system. The present system works 
great for our requirements.
\item We have an option to move to git, but Launchpad does not support git, so the tight 
integration would be lost.
\end{itemize}


\section{Internet Relay Chat}
\section{Mailing lists}