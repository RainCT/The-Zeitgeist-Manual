\section{Languages used}

\subsection{Zeitgeist Engine}
The Zeitgeist engine is primarily written in Python and minimum supported version is Python 2.7


\subsection{Zeitgeist Datahub}
Zeitgeist datahub is a passive logger for zeitgeist. It is written in 
vala, since it gives a great flexibilities. It gives us the good features 
of a high level language which compiles down to native code. 

The high level language features helps in bringing down the effort we
put in maintaince, so that the workforce can be used in work which needs 
more attention. It helps us in an efficient use of manpower, esp in a 
volunteer run project.

On the performace side, it needs to be lightweight as it is running all 
the time. The earlier python based datahub used 5 times more memory.

\subsection{Libraries}
We have a libraries which are basically language or framework bindings 
for Zeitgeist API. Most of these bindings actually wrap over the 
Zeitgeist DBus API using the dbus binding for that specific package. 
We have bindings for Python, C/Vala, Qt and Mono.
\subsection{Datasources}
Datasources are written in multiple languages and uses the language which 
the application supports. Example Emacs datasource is written in lisp, 
tomboy datasource is written in C\#, Rhythmbox datasource is written in 
python and so on.
\subsection{Why Python for Engine?}
GNOME Zeitgeist started from the Gimmie/Mayanna codebase that was written 
in python. The tradition continued. Although we had several thoughts to move 
to Mono, C and Vala it never happened for several reasons. 
\begin{itemize}
\item Mono would have created a big debate in the community since a lot of 
GNOME hackers dislike it, however at the very beginning all ZG developers were 
keen with mono, yet to ensure no political issues we decided to stay with python.
\item C was and still is an issue since, only a few or the core devs are familiar 
with C and we will lose momentum.
\item Vala would have made Zeitgeist more a GNOME project than a desktop project 
and there is not much gain now in moving to any other programing language since 
speed and memory consumption wont be affected heavily in comparison to the effort 
we will have to put in it. That time Vala wasn't an option either because it 
doesn't support some D-Bus features we needed.
\end{itemize}


\section{Other technologies}
\subsection{SQLite}
SQLite is a embedded relational database management system with ACID compliant. It 
has a very small size which makes it ideally suited for wide varities of uses. It is 
classified as a flat file database as opposed to most of the database systems which 
run as a server-client model.

Every SQLite database is represented as a file on the disk. It has bindings for most 
of the languages with which it is accessed. SQLite is said to be the world's most 
deployed database system. Lots of applications use SQLite. Some of them are listed: 
\begin{itemize}
\item \textbf{Adobe} - Adobe Lightroom, Adobe Integrated Runtime
\item \textbf{Apple} - Safari, Aperture, Apple Mail
\item \textbf{Mozilla} - Firefox, Thunderbird
\item \textbf{Google} - Google Gears, Android, Chrome browser
\end{itemize}


The advantage of SQLite are numerous:
\begin{enumerate}
\item It reduces latency by avoiding server-client model and directly accessing 
the database file.
\item The size of the library is very small and can be used in space-constained 
applications. 
\item Even though being very small in size, it still implements ACID which 
gives it transaction feature.
\end{enumerate}

\subsection{DBus}
DBus is a simple Interprocess-communication system used by applications to communicate 
with each other. It is available for POSIX operating systems and a windows port is 
available which is does not work so well. DBus is a freedesktop project.

DBus runs as a daemon on the local system. There are two kind of instance. One is a 
single system wide daemon called SystemBus and per user instance called as SessionBus. 

Every application can start a SessionBus to let other applications communicate with it. 
Applications can then connect to the application on interfaces and call methods on the 
interface to interact with the application which started the SessionBus.
\subsection{GLib}
GLib is one of the core building block of for applications and libraries which are 
written in C. It provides the basic functionality like data strutures, threading, mutex, 
message passing, hook functions and many more.

\section{Launchpad}

Launchpad is a web based application for software development and collaboration for 
free software. It is actually a suite of various services which is tightly integrated 
with each other. Some of the services are:
\begin{itemize}
\item Code hosting (uses Bazaar)
\item Bug tracker (codenamed Malone)
\item Question and Answers
\item Package Management (codenamed Soyuz)
\item Translations (codenamed Rosetta)
\item Blueprints
\item Registry - Projects, Teams and Mailing lists
\end{itemize}

Launchpad is a great development and collaborative platform which is already being used 
to develop Ubuntu, the most famous and widespread Linux distribution. Apart from the 
distribution there are many other smaller or bigger projects which are developed like 
Drizzle, Inkscape, Upstart, Zope3, OpenStack, Bazaar, OpenShot, Docky and MySQL.

\subsection{Why Launchpad is good for our workflow}
\subsection{How we found value in Launchpad's bug tracker}
Launchpad's bug tracker contains many good features which are of immense help for our 
project. Some of them are
\begin{enumerate}
\item A problem in zeitgeist can affect various modules of zeitgeist. It is important for 
us to track the same bug in all the modules. Instead of having multiple bugs opened for 
all for them, one bug reports tracks status in all the affected modules.
\item Since Ubuntu also uses Launchpad for management, we can track an issue in our codebase 
as well as the one present in Ubuntu at the same time. It also allows us to track the issues 
of zeitgeist in each ubutu version seperately which helps us know the complete history 
of the current problem.
\item An problem in zeitgeist might be due to a bug in one of our dependencies which might 
not be developed in Launchpad. In such a case this same issue is opened upstream on that 
project's bug tracker and a \textit{bug watch} is added to the corresponding issue in Launchpad. 
The work of bug tracker is to keep a watch on the upstream bug and import the updates from that 
upstream bug on Launchpad so that the bug triagers or developers don't have to keep watch 
everywhere. This simplifies bug management.
\item Launchpad allows us to subscribe to bug reports. The beauty of this subscription is that 
it allows us to configure our subscription to fine-grained level on each bug seperately. It 
allows someone to subscribe someone anyone on a bug.
\item It keeps the comments on the bug and the changes made to the status and importance of 
each affected project seperately. Patches and attachment are also shown in the comment in 
strict oldest to newer order. All the attachments and patches are also shown on the right 
side if someone is interested in looking at all of them, especially in bug reports with lots 
of activity.
\end{enumerate}
\subsection{Why tightly integrated Launchpad helps us}

\section{Bazaar}
Bazaar is a distributed version control system. Using a distributed version control 
system like bazaar developers can collaborate in a completely distributed manner 
without having to know what code changes the other developer is doing. Every developer 
has a complete copy of the source code with all the change history.

To collaborate amongst the developers there is a centralized server where all the 
developers can push code and pull changes made by others. Let us imagine a scenario 
in which various developers have to collaborate.
\begin{enumerate}
\item The central server contains the source code.
\item Three developers make a clone of the source code using bazaar.
\item All three of them go to some place without an internet connection.
\item All of them keep making changes to the codebase.
\item Developer A pushes his code on the server.
\item Rest two developers pull from the server and get Developer A's changes.
\item Developer B pushes his changes.
\item Developer A and C pull the changes.
\item Developer A has B's changes and Developer B has Developer A's changes.
\item Developer C has changes from all the two developers plus his own.
\item Developer C pushes the changes on the server.
\item Developer A and B pull th changes from the server.
\item Now all the three developers have each other changes and server has changes 
from all three of them.
\end{enumerate}

Bazaar also maintains history of the changes. It can be told to keep a watch on the 
files specified and it can then tell which files have changes and what has changed. It 
can even tell the contents which has changes. After making some changes we can commit the 
changes. Each commit is like a \textbf{milestone}. All the changes made after the commit are 
called changes, which can be then committed. Anytime a person can see the changes 
made between the various commits. 

It is advisable to have one logical unit of work in a commit instead of making 10,000 
lines of changes in a single commit. Example changes made to add a new entry in the toolbar 
can qualify as a commit. If the changes are very big, then this should be broken down into 
smaller and more managable changes. 

There are many reasons for keeping the changes in a single commit small and managable: 

\begin{itemize}
\item The changes made between commits can be viewed by a diff tool like \textit{kdiff} and \textit{meld}. 
If changes are small, reading and understanding the changes is easier.
\item When changes are small, it is easy to find out the commit which introduced a regression.
\item Many times code is submitted for review before it is accepted. Having a huge 8000 lines 
of changes makes it very difficult for the maintainer of the project to understand.
\end{itemize}

\subsection{Why did we pick up Bazaar}
There were multiple reasons why we chose Bazaar and then later continued with it: 
\begin{itemize}
\item The initial code of Zeitgeist was uploaded on Launchpad which uses Bazaar version control system.
\item Bazaar is simple to use. It takes less time to learn.
\item Bazaar has great integration with Launchpad. This is one important factor.
\item Bazaar has simpler branching and merging concept than other version control systems.
\item We want to make the entry barrier low to the new contributers. We want them to spend more time 
on implementing the actual thing than spend time learning a version control system.
\end{itemize}

\subsection{How tough is to migrate to something else}
There are two major reasons why we do not merge to some other version control system: 
\begin{itemize}
\item It takes time to learn a new distributed version control system. The present system works 
great for our requirements.
\item We have an option to move to git, but Launchpad does not support git, so the tight 
integration would be lost.
\end{itemize}


\section{Internet Relay Chat}

Internet Relay Chat or IRC is a multiuser realtime chat which is specified by IETF RFC 1459 and is used 
by a lot of Open Source projects for collaboration, real time discussion, meetings via texts. It can also 
be used to exchange files.
\\

Since IRC is a standarized protocol there exists many IRC networks like Freenode, DALnet, OFTC and 
GIMPnet. Each IRC network can have multiple channels. Infact anyone can create a new channel and start 
using it for their work. Each network has it's own Terms of Service which needs to be respected.
\\

Freenode, OFTC and GIMPnet are one of the few biggest IRC networks for Open Source projects. Zeitgeist uses 
Freenode network for running it's IRC channel. Our channel is named \#zeitgeist. All the official channels 
start with a \# and unofficial channels start with \#\#. Example unofficial Ubuntu chit-chat channel "Club Ubuntu" 
has the channel name \#\#club-ubuntu
\\

IRC has helped zeitgeist development immensely. We all zeitgeist developers spend most of our time spent 
for collaboration on IRC. We have meetings and random sporadic discussions related to performance and new 
feature sets. IRC is also a great place where we can meet our users who are having issues. We also provide 
support to users. There are developers who want to add zeitgeist support in their application. All of these 
use cases are perfectly handled by Internet Relay Chat.

\section{Mailing lists}

Mailing lists are discussion medium which uses email service for discussion. People who want to take part in a 
discussion register their email address on the mailing list service. Every mailing list service has a dedicated 
email address which acts as the contact point for that group. 
\\
If a person needs to start a discussion, he needs to send a mail to the mailing list address which takes care of 
sending that mail to the subscribed members. Those people who want to reply to that mail, send a reply to 
the mailing list email address and everyone gets the mail.
\\
Usage of mailing lists brings an interesting observation. Developers keep coming in and leaving the project, so 
there needs to be a email address which represents the development community. Other option would have been to 
send a mail to each and every developer and then they reply back to everyone else. This setup has many problems. 
A few of them are
\begin{enumerate}
\item If the development team is very big, then sending mails to so many people can be tedious. Additionally, 
many mail servers would block such a mail send to so many people.
\item The contents of the discussion is not publicly available and archived as the discussion is private. Open 
source projects pride themselves in transparency and public setup (also called Bazaar model of development)
\item A person who wants to leave the development might need to send mail to everyone else to remove him from 
the discussion. Maintaing the whole list of people interested in discussion would become another problem.
\item If a new member needs to join the discussion, then he needs to ask everyone in the team. Since in this 
model the discussion is private, he might not know who all he needs to ask. He might not even know that 
there is a such a discussion going on.
\item In this model, the entire list of email addresses can get leaked which might end up in hand of spammers.
\end{enumerate}

Now let us see how this problem is solved by mailing lists approach:\
\begin{enumerate}
\item An individual has the full control when he wants to join or depart from the mailing list.
\item The public archive of the discussion is maintained by the mailing list software. This can be either public 
or private depending on the policies of the mailing list.
\item A person does not need to have the headache of sending mail to each and every person. He just sends the mail 
to the mailing list address and the rest is taken care by the mailing list software.
\item It is possible to subscribe to the digest version of mailing list discussion if a person just wants to read the 
summary of the information rather than actively participating in the discussion.
\end{enumerate}

Zeitgeist uses GNU Mailman which is probably the most widely used mailing list software. The email address for our 
mailing lists are
\begin{itemize}
\item Development - dev@lists.zeitgeist-project.com
\item Users - gnome-zeitgeist-users@lists.launchpad.net
\end{itemize}

We keep out subscribed user list private to protect the email addresses from getting harvested by spam bots. To promote 
transparency we keep our discussion archives public and searchable by search engines like google search.
